jmp cmd_fibbo_end
cmd_fibbo_exe:
call PUSHSTATE
xor bx, bx
mov cx, 1
mov bp, 0
cmd_fibbo_exe_start:
mov ax, bx
call PRINT_AX
mov ah, endl
int 1
add bx, cx
mov dx, cx
mov cx, bx
mov bx, dx

cmp rm, bp
je cmd_fibbo_exe_start

call POPSTATE
ret

#string cmd_shutdown_msg "Shutting down"
cmd_shutdown_exe:
  mov adr, cmd_shutdown_msg
  call WRITE
  mov ah, '.'
  mov bx, 10   ; cycles to sleep
  call SLEEP
  int 1
  call SLEEP
  int 1
  call SLEEP
  int 1
  call SLEEP
  ; clear screen
  mov ah, 12
  int 1
  ; shut down
  mov ah, 0
  int 0xffff
ret


cmd_motd_exe:
  mov adr, cmd_motd
  call WRITE
ret

#string cmd_help_head "List of commands:\n"
#string cmd_help_hyphen " - "

cmd_help_exe:
  call PUSHSTATE
  mov adr, cmd_help_head        ; vypiseme cmd_help_head
  call WRITE
  mov adr, os_cmdlist           ; nacteme zacatek seznamu do adr
  mov bp, os_cmdlistend         ;         konec seznamu do adr
  mov ah, endl                  ;         konec radku do ah
    cmd_help_loop:
    iadd adr, 2                 ; ve stringu preskocime jmp command
    call WRITE                  ; vypiseme command
    push adr                    ; push aktualni adresy
    mov adr, cmd_help_hyphen    ; vypsani pomlcky
    call WRITE
    pop adr                     ; pop aktualni adresy
    iadd adr, 3                 ; ve stringu preskocime jmp command - v tomto pripade 3 slova
    call WRITE                  ; vypiseme popis commandu
    int 1                       ; zalomeni radku - v ah je porad endl
    iadd adr, 1                 ; skok na zacatek jmp
    cmp adr, bp                 ; zjistime jestli nejsme na konci seznamu
    jl cmd_help_loop            ; pokud ne, opakujeme
  call POPSTATE
ret


cmd_clrscrn_exe:
call PUSHSTATE
mov ah, 12
int 1
call POPSTATE
ret

cmd_shunt_yard_exe:
call PUSHSTATE
jmp program
and ah, ah
op_stack:
#string opstack "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
op_stack_end:
mov bl, 0 ; bl = typ tokenu
mov bh, opstack ; bh = op_stack pointer

; 0 - nic
; 1 - cislo
; 2 - operator    -  42:  *+,-./
; 3 - paranteses  -  40=left 41=right
; dx = hodnota tokenu

;;;;;;;;;;;;;;;; ZACATEK ALGORITMU ;;;;;;;;;;;;;;;;;;;
 
program:

mov adr, READLN_STACK
loop:               ;zacatek cteni inputu
mov al, [adr]       ;prvni znak vlozen do al registeru
add adr, 1          ;posunuti na dalsi znak

mov ah, 48          ; Pokud je znak <48 nebo >57, neni cislo
cmp al, ah          ;
jl not_digit        ;
                    ;
mov ah, 57          ;
cmp al, ah          ;
jg not_digit        ;

sub al, 48          ; definitely a digit
mov dx, al          ;
mov bl, 1           ;         


;;;;;;;;;;;;;;;;; TOKENIZACE CISEL ;;;;;;;;;;;;;;;;;;;

loop_digit:

mov al, [adr]
          
cmp al, 48          ; pokud je znak mensi nez 48, konci cislo
jl end_token        ; ergo konec tokenu
          
cmp al, 57          ; pokud je znak vetsi nez 57, konci cislo
jg end_token        ; ergo konec tokenu

isub al, 48         ; subtract ASCII bias
iadd adr, 1         ; posunuti o znak dale

mul dx, 10          ; vynasobeni predchoziho cisla desiti
add dx, al          ; pricteni nove cifry k predchozimu cislu
jmp loop_digit

;;;;;;;;;;;;;;; TOKENIZACE OPERATORU ;;;;;;;;;;;;;;;;;

not_digit:


cmp al, '+'
je yes_operator
cmp al, '-'
je yes_operator
cmp al, '*'
je yes_operator
cmp al, '/'
je yes_operator

jmp not_operator

yes_operator:
mov bl, 2
mov dx, al
jmp end_token

;;;;;;;;;;;;;;; TOKENIZACE ZAVOREK ;;;;;;;;;;;;;;;;;;

not_operator:                
cmp al, '('
je yes_parenthesis
cmp al, ')'
je yes_parenthesis

jmp not_parenthesis

yes_parenthesis:
mov bl, 3
mov dx, al
jmp end_token
not_parenthesis:

error:
mov ah, '!'
error_loop:
int 1
jmp error_loop
  
;;;;;;;;;;;;;;;; ZPRACOVANI TOKENU ;;;;;;;;;;;;;;;;;;

end_token:
cmp bl, 1               ; pokud je cislo, je jiz hotovo
je push_token           ;  =====> push do output stacku
cmp bl, 2               ; pokud je operator, zacne zpracovavat precedenci
je process_operator     ; 
cmp bl, 3               ; pokud je zavorka, zacne hledat
je process_parenthesis  ; druhou zavorku v operator stacku, resp. pushne se na operator stack
jmp error

;;;;;;;;;;;;;;;;;;;;; OPERATORY ;;;;;;;;;;;;;;;;;;;;;;

process_operator:    ; urceni precedence operatoru a nasledne zpracovani podle hodnoty
cmp dx, '+'
je precedence_2_token
cmp dx, '-'
je precedence_2_token
cmp dx, '*'          
je precedence_3_token          
cmp dx, '/'
je precedence_3_token  ; precedence TOKENU je v !ah! registru

operator_loop:       
jmp op_stack_read      ; priprava k porovnani s poslednim operatorem na operator stacku
cmp ch, '+'
je precedence_2_stack
cmp ch, '-'
je precedence_2_stack
cmp ch, '*'
je precedence_3_stack
cmp ch, '/'
je precedence_3_stack  ; precedence POSLEDNI OPERATORU NA OPERATOR STACKU je v !ch! registu

cmp dx, ch                ; porovnavani precedenci
jg  precedence_greater
cmp dx, ch
je  precedence_equal_less
cmp dx, ch
jl  precedence_equal_less


precedence_greater:    ; pokud je precedence tokenu vetsi, pushne token na  operator stack a zacne
jmp op_stack_push      ; zpracovavat novy token
jmp loop
precedence_equal_less: ; pokud je precedence tokenu rovna nebo mensi, token na operator stacku se popne                       
sub bh, 1              ; nasledne se pushne na output stack a zkontroluje se precedence dalsiho operatoru
mov cl, [bh]
push adr
mov adr, cl
call WRITE
pop adr
jmp operator_loop 
precedence_2_token:    
mov ah, 2
ret
precedence_3_token:
mov ah, 3
ret
precedence_2_stack:
mov ch, 2
ret
precedence_3_stack:    
mov ch, 3
ret

;;;;;;;;;;;;;;;;;;;;;; ZAVORKY ;;;;;;;;;;;;;;;;;;;;;;;
 
process_parenthesis: ; zpracovani soucasne zavorky a operator stacku
cmp dx, 40           ; pokud je zavorka leva, pushne se na operator stack
je op_stack_push     
cmp dx, 40           ; a hned pote se zacne zpracovavat novy token 
je loop                    
parenthesis_find:    ; zavorka je 100% prava a v operator stacku se zacina hledat leva zavorka 
jmp op_stack_pop
cmp dx, 40           ; pokud se najde leva zavorka, obe zavorky se zahodi (al registr bude hned po jumpu prepsan novym tokenem)
je loop
call print_token      ; pokud ne, prave popnuty operator se pushne na output stack 
jmp parenthesis_find

;;;;;;;;;;;;;;;;;;; PUSH TOKENU ;;;;;;;;;;;;;;;;;;;;;;
 
push_token:          ; pushnuti jiz zpracovaneho tokenu na output stack
call print_token
jmp loop

;;;;;;;;;;;;;;;;;; KONEC ALGORITMU ;;;;;;;;;;;;;;;;;;;

print_token:         ; vypíše token na obrazovku
push adr
mov adr, dx
call WRITE
pop adr
ret
op_stack_push:       ; pushne token na operator stack
mov [bh], dx
add bh, 1
ret
op_stack_pop:        ; popne token z operator stacku
sub bh, 1            
mov dx, [bh]
ret
op_stack_read:       ; precte posledni token na operator stacku
mov al, [bh]
ret
exe_shunt_yard_end:
int 1
call POPSTATE
ret                  




cmd_fibbo_end:
